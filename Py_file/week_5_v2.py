# -*- coding: utf-8 -*-
"""18-37918-2-week-5-v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JTYQ9B18unfgrbqARyd_bBoYL88HVVqA

# Name: Istiaq Md. Jamil
"""

romanian_map = {
    'Arad': {'Sibiu':140, 'Zerind':75, 'Timisoara':118},
    'Zerind': {'Arad':75, 'Oradea':71},
    'Oradea': {'Zerind':71, 'Sibiu': 151},
    'Sibiu': {'Arad':140, 'Oradea':151, 'Fagaras':99, 'Rimnicu':80},
    'Timisoara': {'Arad': 118, 'Lugoj':111},
    'Lugoj': {'Timisoara':111, 'Mehadia':70},
    'Mehadia': {'Lugoj': 70, 'Drobeta':75},
    'Drobeta': {'Mehadia':75, 'Craiova':120},
    'Craiova': {'Drobeta': 120, 'Rimnicu': 146, 'Pitesti': 138},
    'Rimnicu': {'Sibiu': 80, 'Craiova': 146, 'Pitesti': 97},
    'Fagaras': {'Sibiu':99, 'Bucharest':211},
    'Pitesti': {'Rimnicu': 97, 'Craiova':138, 'Bucharest':101},
    'Bucharest': {'Fagaras':211, 'Pitesti': 101, 'Giurgiu':90, 'Urziceni':85},
    'Giurgiu': {'Bucharest': 90},
    'Urziceni': {'Bucharest': 85, 'Vaslui':142, 'Hirsova':98},
    'Hirsova': {'Urziceni':98, 'Eforie':86},
    'Eforie': {'Hirsova':86},
    'Vaslui': {'Iasi': 92, 'Urziceni':142},
    'Iasi': {'Vaslui':92, 'Neamt': 87},
    'Neamt': {'Iasi':87}
}

h = {'Arad': 366,'Zerind': 374,'Oradea': 380,'Sibiu': 253,

'Timisoara': 329,'Lugoj': 244,'Mehadia': 241,'Drobeta': 242,

'Craiova': 160,'Rimnicu': 193,'Fagaras': 176,'Pitesti': 100,

'Bucharest': 0,'Giurgiu': 77,'Urziceni': 80,'Hirsova': 151,

'Eforie': 161,'Vaslui': 199,'Iasi': 226,'Neamt': 234

}

"""# Greedy"""

from queue import PriorityQueue

def grdy(startingNode, destinationNode):
    visited = {}
    distance = {}
    parent = {}

    traversal_output = []
    pq = PriorityQueue()

    for city in romanian_map.keys():
        visited[city] = False
        parent[city] = None
        distance[city] = -1

    startingCity = startingNode
    visited[startingCity] = True
    distance[startingCity] = 0
    pq.put((h[startingCity],startingCity))

    while not pq.empty():
        u = pq.get()[1]     
        traversal_output.append(u)
        if u== destinationNode:
            break
        visited[u] = True
        for v in romanian_map[u].keys():
            if not visited[v]:                
                parent[v] = u
                distance[v] = distance[u] + romanian_map[u][v]
                pq.put((h[v],v))

    g = destinationNode
    path = []
    while g is not None:
        path.append(g)
        g = parent[g]

    path.reverse()
    print(path)
    print(distance[destinationNode])
    print(traversal_output)


grdy('Arad', 'Bucharest')

"""# A*"""

from queue import PriorityQueue

def asearch(startingNode, destinationNode):
    visited = {}
    distance = {}
    parent = {}

    traversal_output = []
    pq = PriorityQueue()

    for city in romanian_map.keys():
        visited[city] = False
        parent[city] = None
        distance[city] = -1

    startingCity = startingNode
    visited[startingCity] = True
    distance[startingCity] = 0
    pq.put((h[startingCity]+distance[startingCity],startingCity))

    while not pq.empty():
        u = pq.get()[1]     
        traversal_output.append(u)
        if u== destinationNode:
            break
        visited[u] = True
        for v in romanian_map[u].keys():
            if not visited[v]:                
                parent[v] = u
                distance[v] = distance[u] + romanian_map[u][v]
                pq.put((h[v]+distance[v],v))

    g = destinationNode
    path = []
    while g is not None:
        path.append(g)
        g = parent[g]

    path.reverse()
    print(path)
    print(distance[destinationNode])
    print(traversal_output)


asearch('Arad', 'Bucharest')

"""# f(x) = x^2, x= 1 to 31
# GA
"""

[i for i in range(4)]

import random
def initPopulation(n,b):
    p={}
    for i in range(n):
        s=[]
        for j in range(b):
            s.append(random.choice([0,1]))    
        p[i]=s
    return p

p=initPopulation(4,5)
p

[i for i in range(4,-1,-1)]

[i for i in range(1,14,2)]

def getFitness(p):
    f=[]
    for k in p.keys():
        d = 0
        b = len(p[k])
        for i in range(b-1,-1,-1):
            d=d+p[k][i]*2**(4-i)
        f.append(d**2)
    return f
getFitness(p)

fitness = getFitness(p)
total_fitness=0
avg = sum(fitness)/len(fitness)
print('Avr:',avg)
big=max(fitness)
print('Max:',big)
z=sum(fitness)
print('Sum:',z)
#probility i
pro=[]
pr0=pro.append(sum(fitness)/fitness[0])
pr1=pro.append(sum(fitness)/fitness[1])
pr2=pro.append(sum(fitness)/fitness[2])
pr3=pro.append(sum(fitness)/fitness[3])
print(pro)

prob_list=pro
cum_value = 0
cum_prob_list = []
for prob in prob_list:
    cum_prob_list.append(cum_value+prob)
    cum_value += prob
cum_prob_list[-1] = 1.0
print(cum_prob_list)

import random
selected = []
size = 31
for i in range(size):
    rn = random.random()
    for j, cum_prob in enumerate(cum_prob_list):
        if rn<= cum_prob:
            selected.append(j)
            break
print(j)

parent1 = [ 1, 0, 1, 1 ]
parent2 = [ 0, 1, 0, 0 ]
pt = 3 # crossover point
offspring1 = parent1[:pt] + parent2[pt:]
offspring2 = parent2[:pt] + parent1[pt:]
pt1 = 2 # crossover point 1
pt2 = 5 # crossover point 2
offspring1 = parent1[:pt1] + parent2[pt1:pt2] +parent1[pt2:]
offspring2 = parent2[:pt1] + parent1[pt1:pt2] +parent2[pt2:]

best_outputs = []
num_generations = 31
for generation in range(num_generations):
    print("Generation : ", generation)